const { extname } = require('path')

const DELIMETER = '@'
let imagesDataCache

/**
 * Get image size variations
 * @param {string}   src                    Path to image with filename
 * @param {object[]} imagesData             Specific object with information about each image.
 *                                          Generated by `grunt-image-size` task
 * @param {string}   [delimeter=DELIMETER]  Delimeters, which marks filename suffix. For instance,
 *                                          `@` for `image@200.jpg`, which is 200px variant
 * @return {object[]} Set of images size variations
 */
const getImageSet = (src, imagesData, delimeter = DELIMETER) => {
  const filepath = src.replace(new RegExp(`${extname(src)}$`), '')

  return imagesData.filter((e) => e.name.startsWith(`${filepath}${DELIMETER}`) || e.name === src)
}

/**
 * Make `srcset` content for `<img>` tag
 * @param {object[]} set Specific object with set of images, which represetns same image
 *                       in varius sizes
 * @return {string} Formed `srcset` attribute
 */
const printImageSet = (set) => {
  if (set.length <= 1) return

  let srcset = ''

  set.forEach((s, i) => {
    const isLast = i + 1 === set.length
    srcset += `${s.name} ${s.width}w${isLast ? '' : ', '}`
  })

  return srcset
}

/**
 * Get image size and its srcset
 * @param {string}   src        Path to image with filename
 * @param {object[]} imagesData Specific object with information about each image.
 *                              Generated by `grunt-image-size` task
 * @param {string}   baseDir    Root dir, where build files stored. Used for paths resolving
 * @return {object} Image dimensions info
 */
const imageSize = (src, imagesData, baseDir) => {
  if (typeof src !== 'string') throw new Error(`[imageSize] \`src\` must be a string, \`${typeof src}\` provided`)

  if (src.startsWith('http') || src.startsWith('ftp')) return { src, srcset: () => null }

  if (!src.startsWith('/')) throw new Error(`[imageSize] document-relative urls not supported yet, \`${src}\` provided`)
  if (typeof baseDir !== 'string') throw new Error(`[imageSize] \`baseDir\` must be a string, \`${typeof baseDir}\` provided`)
  if (!Array.isArray(imagesData)) throw new Error(`[imageSize] \`imagesData\` must be an array, \`${typeof imagesData}\` provided`)

  if (!imagesDataCache) {
    imagesDataCache = imagesData.map((e) => {
      e.name = e.name.replace(baseDir, '')
      return e
    })
  }

  const image = imagesDataCache.find((e) => src === e.name)

  if (!image) throw new Error(`[imageSize] image \`${src}\` did not match any image data`)

  return {
    src,
    width: image.width,
    height: image.height,
    set: () => getImageSet(src, imagesDataCache),
    srcset: () => printImageSet(getImageSet(src, imagesDataCache))
  }
}

module.exports = imageSize
